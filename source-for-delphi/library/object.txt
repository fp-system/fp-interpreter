'("object.txt" loaded)

// isundef == id = .. '_undef // provi!

topdip == ...
dip == prop°(top°arg),(tag°arg),((top°term) app pop°arg), // vergleichen!

is == ((isobj°[0])->([1]=top°[0])|'false)°ee // super?

// isobj: (((list :: xxx yyy zzz _s) ; bbb ;) ; ([sel1] sweeop term1 _s) ;)
swop == ( (isobj°[0]°[0])->(((isundef->quote|id)°(top°[0]°[0]) iget top°[1]) app [0])
        | (pop°[1]) app [0] )
        °(([1]ee[0])°ee°arg) ee term

// ((obj1 :: aa bb cc _s) _combine sel1 fn term1 _s)
fn == (isobj°arg) -> (((isundef->quote|id) ° ((top°arg) iget top°term)) app arg)
                   | (pop°term) app arg

// ((sel cb fcb _s) _combine (f0 (sel cb fcb _s) f1 _s) _combine .. xx)
cb == ( (isobj°[0]°[0])->(((isundef->quote|id)°(top°[0]°[0]) iget top°[1]) app [0])
      | (pop°[1]) app [0] )
      °((((top°term) app arg),((pop°term) app arg),arg,)°arg) ee term

new == (([0] obj) ([new] op '[new] error '"fail in new",id,) [1])°ee // komma hinter id ? ,fail°'[new],id

as == [as] op '[as] error '"object-type for operand[0] expected.",id, // space [0] ?

// object == .. {( ) }
// turtle01==..{object [new]==initturtle as top°self} // as mit top oder nur self ?

// ------- standard classes -------

; == () termoarg .. list // { [add]==box°(unbox°[0])++unbox°[1] } // ? for box // + test

_integer == .. { [ispos] == ispos°unbox
                 [add]   == box°(unbox°[0])+(unbox°[1]) } // test

_real    == .. { [ispos] == ispos°unbox
                 [pred]  == box°pred°unbox
                 [succ]  == box°succ°unbox}

object == .. {( ) [as] == [1] obj pop°[0]} // as richtig ?

list == .. { object
             [head]  == head°pop
             [tail]  == tail dip
             [infix] == infix°pop
             [comma] == (top°[0]) obj [1],pop°[0] // swop
             [add]   == (top°[0]) obj (+ aa)°trans°(pop°[0]),(pop°[1]), // oop mit trans? // topdip+pop... // unbox!!!
             [reverse] == reverse dip
          // ...
             [ispos] == ispos°pop // test...
             [pred]  == pred dip
             [succ]  == succ dip
             [abs]   == abs dip}

//dict == .. { }

isvector == id is 'vector
tovector == 'vector obj id

vector == .. {
     [add] == (isvector°[1])->((top°[0])obj(+ aa)°trans°(pop°[0])ee(pop°[1]))|fail
     [sub] == (isvector°[1])->((top°[0])obj(- aa)°trans°(pop°[0])ee(pop°[1]))|fail
  }

// is vervollkommnen
// length für xobject

// (CC-BY-3.0-DE) Fpstefan